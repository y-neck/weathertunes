{"v":"4.8.0","meta":{"g":"LottieFiles AE 3.5.7","a":"","k":"","d":"","tc":""},"fr":25,"ip":0,"op":167,"w":500,"h":500,"nm":"Now-Playing_neg","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Shape Layer","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[100,250,0],"ix":2},"a":{"a":0,"k":[13.946,15.584,0],"ix":1},"s":{"a":0,"k":[74,74,100],"ix":6,"x":"var $bm_rt;\nvar fx = effect('Scale | Swink');\nvar AValue = fx(3).value;\nvar BValue = fx(4).value;\nvar frequencyProp = fx(7);\nvar interpolationValue = fx(12).value;\nvar rateValue = fx(13).value;\nvar offsetValue = fx(8).value;\nvar ratioValue = fx(9).value;\nvar plateauValue = fx(10).value;\nvar result = value;\nvar frequencyValue = frequencyProp.value;\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof bezierPoints === 'undefined')\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return $bm_div($bm_sum(value1, value2), 2);\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return $bm_div($bm_sum(value1, value2), 2);\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction gaussianInterpolation(t, tMin, tMax, value1, value2, rate) {\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 0;\n    if (value1 == value2)\n        return value1;\n    if (t >= tMax)\n        return value2;\n    if (t <= tMin)\n        return value1;\n    if (t != tMin) {\n        var newValue1 = gaussianInterpolation(tMin, tMin, tMax, value1, value2, rate);\n        var offset = $bm_sub(newValue1, value1);\n        value1 = $bm_sub(value1, offset);\n    }\n    if (rate < 0)\n        rate = $bm_mul(rate, 10);\n    rate = linear(t, tMin, tMax, 0.25, rate);\n    var r = $bm_sub(1, rate);\n    var fwhm = $bm_mul($bm_sub(tMax, tMin), r);\n    var center = tMax;\n    if (t >= tMax)\n        return value2;\n    if (fwhm === 0 && t == center)\n        return value2;\n    else if (fwhm === 0)\n        return value1;\n    var exp = $bm_mul(-4, Math.LN2);\n    exp *= Math.pow($bm_sub(t, center), 2);\n    exp *= $bm_div(1, Math.pow(fwhm, 2));\n    var result = Math.pow(Math.E, exp);\n    result = $bm_sum($bm_mul(result, $bm_sub(value2, value1)), value1);\n    return result;\n}\nfunction logInterpolation(t, tMin, tMax, vMin, vMax, rate) {\n    var value1, value2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 1;\n    if (rate == 0)\n        return linearExtrapolation(t, tMin, tMax, vMin, vMax);\n    tMax = $bm_sum($bm_mul($bm_sub(tMax, tMin), rate), 1);\n    t = $bm_sum($bm_mul($bm_sub(t, tMin), rate), 1);\n    if (t <= 1)\n        return vMin;\n    var m = Math.log(tMax);\n    var v = Math.log(t);\n    return linearExtrapolation(v, 0, m, vMin, vMax);\n}\nfunction expInterpolation(t, tMin, tMax, vMin, vMax, rate) {\n    var value1, value2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 1;\n    if (rate == 0)\n        return linearExtrapolation(t, tMin, tMax, vMin, vMax);\n    tMax = $bm_mul($bm_sub(tMax, tMin), rate);\n    t = $bm_mul($bm_sub(t, tMin), rate);\n    var m = Math.exp(tMax);\n    t = Math.exp(t);\n    return linearExtrapolation(t, 1, m, vMin, vMax);\n}\nfunction integrateLinearKeys(prop) {\n    if (typeof prop === 'undefined')\n        prop = thisProperty;\n    var nK = prop.numKeys;\n    if (nK < 2)\n        return $bm_mul(prop.value, $bm_sub(time, inPoint));\n    if (prop.key(1).time > time)\n        return $bm_mul(prop.value, $bm_sub(time, inPoint));\n    var result = $bm_mul(prop.key(1).value, $bm_sub(prop.key(1).time, inPoint));\n    for (var i = 2; i <= nK; i++) {\n        if (prop.key(i).time > time)\n            break;\n        var k1 = prop.key($bm_sub(i, 1));\n        var k2 = prop.key(i);\n        result = $bm_sum(result, $bm_div($bm_mul($bm_sum(k1.value, k2.value), $bm_sub(k2.time, k1.time)), 2));\n    }\n    result = $bm_sum(result, $bm_div($bm_mul($bm_sum(prop.value, prop.key($bm_sub(i, 1)).value), $bm_sub(time, prop.key($bm_sub(i, 1)).time)), 2));\n    return result;\n}\nfunction interpolateColor(t, colorspace, tMin, tMax, colorA, colorB, interpolationMethod) {\n    if (typeof t === 'undefined')\n        t = time;\n    if (typeof colorspace === 'undefined')\n        colorspace = 2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof colorA === 'undefined')\n        colorA = [\n            0,\n            0,\n            0,\n            0\n        ];\n    if (typeof colorB === 'undefined')\n        colorB = [\n            1,\n            1,\n            1,\n            1\n        ];\n    if (typeof interpolationMethod === 'undefined')\n        interpolationMethod = ease;\n    var result = [\n            0,\n            0,\n            0,\n            0\n        ];\n    if (colorspace > 0 && colorspace < 4) {\n        var a = rgbToHsl(colorA);\n        var b = rgbToHsl(colorB);\n        var dist = Math.abs($bm_sub(a[0], b[0]));\n        result = interpolationMethod(t, tMin, tMax, a, b);\n        if (dist > 0.5 && colorspace == 2 || dist < 0.5 && colorspace == 3) {\n            var hA = a[0];\n            var hB = b[0];\n            var h = hA;\n            dist = $bm_sub(1, dist);\n            if (hA < hB) {\n                var limit = $bm_mul($bm_div(hA, dist), tMax);\n                if (t < limit)\n                    h = interpolationMethod(t, tMin, limit, hA, 0);\n                else\n                    h = interpolationMethod(t, limit, tMax, 1, hB);\n            } else {\n                var limit = $bm_mul($bm_div($bm_sub(1, hA), dist), tMax);\n                if (t < limit)\n                    h = interpolationMethod(t, tMin, limit, hA, 1);\n                else\n                    h = interpolationMethod(t, limit, tMax, 0, hB);\n            }\n            result = [\n                h,\n                result[1],\n                result[2],\n                result[3]\n            ];\n        }\n        result = hslToRgb(result);\n    } else {\n        var rgbResult = interpolationMethod(t, tMin, tMax, colorA, colorB);\n        if (colorspace == 0)\n            result = rgbResult;\n        else {\n            var a = rgbToHsl(colorA);\n            var b = rgbToHsl(colorB);\n            var hslResult = interpolationMethod(t, tMin, tMax, a, b);\n            var h = rgbToHsl(rgbResult)[0];\n            result = [\n                h,\n                hslResult[1],\n                hslResult[2],\n                hslResult[3]\n            ];\n            result = hslToRgb(result);\n        }\n    }\n    return result;\n}\nfunction multSets(setA, setB) {\n    var r = [];\n    var countA = setA.length;\n    var countB = setB.length;\n    var count = countA;\n    if (countB < countA)\n        count = countB;\n    for (var i = 0; i < count; i++) {\n        r.push($bm_mul(setA[i], setB[i]));\n    }\n    return r;\n}\nfunction linearExtrapolation(t, tMin, tMax, value1, value2) {\n    if (tMax == tMin)\n        return $bm_div($bm_sum(value1, value2), 2);\n    return $bm_sum(value1, $bm_mul($bm_div($bm_sub(t, tMin), $bm_sub(tMax, tMin)), $bm_sub(value2, value1)));\n}\nfunction blink(A, B, frequency, offset, ratio, t) {\n    if (typeof frequency === 'undefined')\n        frequency = 1;\n    if (typeof offset === 'undefined')\n        offset = 0;\n    if (typeof ratio === 'undefined')\n        ratio = 0.5;\n    if (typeof t === 'undefined')\n        t = time;\n    var phase = $bm_div(1, frequency);\n    var currentTime = $bm_mod($bm_sum(t, offset), phase);\n    var ADuration = $bm_mul(phase, ratio);\n    if (currentTime > ADuration)\n        return B;\n    return A;\n}\nfunction swing(A, B, frequency, offset, ratio, plateau, interpolationMethod, t) {\n    if (typeof frequency === 'undefined')\n        frequency = 1;\n    if (typeof offset === 'undefined')\n        offset = 0;\n    if (typeof ratio === 'undefined')\n        ratio = 0.5;\n    if (typeof plateau === 'undefined')\n        plateau = 0;\n    if (typeof interpolationMethod === 'undefined')\n        interpolationMethod = ease;\n    if (typeof t === 'undefined')\n        t = time;\n    var phase = $bm_div(1, frequency);\n    var currentTime = $bm_mod($bm_sum(t, offset), phase);\n    var ADuration = $bm_mul(phase, ratio);\n    var APlateau = $bm_mul(ADuration, plateau);\n    var BDuration = $bm_mul(phase, $bm_sub(1, ratio));\n    var BPlateau = $bm_mul(BDuration, plateau);\n    if (currentTime < $bm_sub(ADuration, APlateau))\n        return interpolationMethod(currentTime, 0, $bm_sub(ADuration, APlateau), A, B);\n    if (currentTime >= ADuration - APlateau && currentTime < ADuration)\n        return B;\n    if (currentTime >= ADuration && currentTime < phase - BPlateau)\n        return interpolationMethod(currentTime, ADuration, $bm_sub(phase, BPlateau), B, A);\n    return A;\n}\nif (frequencyValue > 0) {\n    offsetValue = $bm_div($bm_div(offsetValue, 100), frequencyValue);\n    ratioValue /= 100;\n    plateauValue /= 100;\n    var t = integrateLinearKeys(frequencyProp);\n    if (interpolationValue == 1)\n        result = $bm_sum(result, blink(AValue, BValue, 1, offsetValue, ratioValue, t));\n    else {\n        var i = linear;\n        if (interpolationValue == 3)\n            i = function (t, tMin, tMax, value1, value2) {\n                return bezierInterpolation(t, tMin, tMax, value1, value2, [\n                    $bm_div(rateValue, 10),\n                    0,\n                    $bm_sub(1, $bm_div(rateValue, 10)),\n                    1\n                ]);\n            };\n        if (interpolationValue == 4)\n            i = function (t, tMin, tMax, value1, value2) {\n                return gaussianInterpolation(t, tMin, tMax, value1, value2, linear(rateValue, 0, 10, -1, 1));\n            };\n        if (interpolationValue == 5)\n            i = function (t, tMin, tMax, value1, value2) {\n                return logInterpolation(t, tMin, tMax, value1, value2, $bm_mul($bm_mul(rateValue, 50), frequencyValue));\n            };\n        if (interpolationValue == 6)\n            i = function (t, tMin, tMax, value1, value2) {\n                return expInterpolation(t, tMin, tMax, value1, value2, $bm_mul(rateValue, frequencyValue));\n            };\n        var interpolator = i;\n        result = $bm_sum(result, swing(AValue, BValue, 1, offsetValue, ratioValue, plateauValue, interpolator, t));\n    }\n}\n$bm_rt = result;"}},"ao":0,"ef":[{"ty":5,"nm":"Scale | Swink","np":16,"mn":"Pseudo/DUIK 2D Swink","ix":1,"en":1,"ef":[{"ty":6,"nm":"Values","mn":"Pseudo/DUIK 2D Swink-0001","ix":1,"v":0},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0002","ix":2,"v":0},{"ty":3,"nm":"A","mn":"Pseudo/DUIK 2D Swink-0003","ix":3,"v":{"a":0,"k":[-175,-175],"ix":3}},{"ty":3,"nm":"B","mn":"Pseudo/DUIK 2D Swink-0004","ix":4,"v":{"a":0,"k":[25,25],"ix":4}},{"ty":6,"nm":"Parameters","mn":"Pseudo/DUIK 2D Swink-0005","ix":5,"v":0},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0006","ix":6,"v":0},{"ty":0,"nm":"Frequency","mn":"Pseudo/DUIK 2D Swink-0007","ix":7,"v":{"a":0,"k":0.15,"ix":7}},{"ty":0,"nm":"Cycle offset","mn":"Pseudo/DUIK 2D Swink-0008","ix":8,"v":{"a":0,"k":0,"ix":8}},{"ty":0,"nm":"A/B Ratio","mn":"Pseudo/DUIK 2D Swink-0009","ix":9,"v":{"a":0,"k":50,"ix":9}},{"ty":0,"nm":"Plateau","mn":"Pseudo/DUIK 2D Swink-0010","ix":10,"v":{"a":0,"k":0,"ix":10}},{"ty":6,"nm":"Interpolation","mn":"Pseudo/DUIK 2D Swink-0011","ix":11,"v":0},{"ty":7,"nm":"Mode","mn":"Pseudo/DUIK 2D Swink-0012","ix":12,"v":{"a":0,"k":3,"ix":12}},{"ty":0,"nm":"Rate","mn":"Pseudo/DUIK 2D Swink-0013","ix":13,"v":{"a":0,"k":3,"ix":13}},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0014","ix":14,"v":0}]}],"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[115.496,115.496],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.949019607843,0.949019607843,0.949019607843,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019607843,0.949019607843,0.949019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[13.946,15.584],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":167,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"Shape Layer 3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[400,250,0],"ix":2},"a":{"a":0,"k":[13.946,15.584,0],"ix":1},"s":{"a":0,"k":[74,74,100],"ix":6,"x":"var $bm_rt;\nvar fx = effect('Scale | Swink');\nvar AValue = fx(3).value;\nvar BValue = fx(4).value;\nvar frequencyProp = fx(7);\nvar interpolationValue = fx(12).value;\nvar rateValue = fx(13).value;\nvar offsetValue = fx(8).value;\nvar ratioValue = fx(9).value;\nvar plateauValue = fx(10).value;\nvar result = value;\nvar frequencyValue = frequencyProp.value;\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof bezierPoints === 'undefined')\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return $bm_div($bm_sum(value1, value2), 2);\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return $bm_div($bm_sum(value1, value2), 2);\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction gaussianInterpolation(t, tMin, tMax, value1, value2, rate) {\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 0;\n    if (value1 == value2)\n        return value1;\n    if (t >= tMax)\n        return value2;\n    if (t <= tMin)\n        return value1;\n    if (t != tMin) {\n        var newValue1 = gaussianInterpolation(tMin, tMin, tMax, value1, value2, rate);\n        var offset = $bm_sub(newValue1, value1);\n        value1 = $bm_sub(value1, offset);\n    }\n    if (rate < 0)\n        rate = $bm_mul(rate, 10);\n    rate = linear(t, tMin, tMax, 0.25, rate);\n    var r = $bm_sub(1, rate);\n    var fwhm = $bm_mul($bm_sub(tMax, tMin), r);\n    var center = tMax;\n    if (t >= tMax)\n        return value2;\n    if (fwhm === 0 && t == center)\n        return value2;\n    else if (fwhm === 0)\n        return value1;\n    var exp = $bm_mul(-4, Math.LN2);\n    exp *= Math.pow($bm_sub(t, center), 2);\n    exp *= $bm_div(1, Math.pow(fwhm, 2));\n    var result = Math.pow(Math.E, exp);\n    result = $bm_sum($bm_mul(result, $bm_sub(value2, value1)), value1);\n    return result;\n}\nfunction logInterpolation(t, tMin, tMax, vMin, vMax, rate) {\n    var value1, value2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 1;\n    if (rate == 0)\n        return linearExtrapolation(t, tMin, tMax, vMin, vMax);\n    tMax = $bm_sum($bm_mul($bm_sub(tMax, tMin), rate), 1);\n    t = $bm_sum($bm_mul($bm_sub(t, tMin), rate), 1);\n    if (t <= 1)\n        return vMin;\n    var m = Math.log(tMax);\n    var v = Math.log(t);\n    return linearExtrapolation(v, 0, m, vMin, vMax);\n}\nfunction expInterpolation(t, tMin, tMax, vMin, vMax, rate) {\n    var value1, value2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 1;\n    if (rate == 0)\n        return linearExtrapolation(t, tMin, tMax, vMin, vMax);\n    tMax = $bm_mul($bm_sub(tMax, tMin), rate);\n    t = $bm_mul($bm_sub(t, tMin), rate);\n    var m = Math.exp(tMax);\n    t = Math.exp(t);\n    return linearExtrapolation(t, 1, m, vMin, vMax);\n}\nfunction integrateLinearKeys(prop) {\n    if (typeof prop === 'undefined')\n        prop = thisProperty;\n    var nK = prop.numKeys;\n    if (nK < 2)\n        return $bm_mul(prop.value, $bm_sub(time, inPoint));\n    if (prop.key(1).time > time)\n        return $bm_mul(prop.value, $bm_sub(time, inPoint));\n    var result = $bm_mul(prop.key(1).value, $bm_sub(prop.key(1).time, inPoint));\n    for (var i = 2; i <= nK; i++) {\n        if (prop.key(i).time > time)\n            break;\n        var k1 = prop.key($bm_sub(i, 1));\n        var k2 = prop.key(i);\n        result = $bm_sum(result, $bm_div($bm_mul($bm_sum(k1.value, k2.value), $bm_sub(k2.time, k1.time)), 2));\n    }\n    result = $bm_sum(result, $bm_div($bm_mul($bm_sum(prop.value, prop.key($bm_sub(i, 1)).value), $bm_sub(time, prop.key($bm_sub(i, 1)).time)), 2));\n    return result;\n}\nfunction interpolateColor(t, colorspace, tMin, tMax, colorA, colorB, interpolationMethod) {\n    if (typeof t === 'undefined')\n        t = time;\n    if (typeof colorspace === 'undefined')\n        colorspace = 2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof colorA === 'undefined')\n        colorA = [\n            0,\n            0,\n            0,\n            0\n        ];\n    if (typeof colorB === 'undefined')\n        colorB = [\n            1,\n            1,\n            1,\n            1\n        ];\n    if (typeof interpolationMethod === 'undefined')\n        interpolationMethod = ease;\n    var result = [\n            0,\n            0,\n            0,\n            0\n        ];\n    if (colorspace > 0 && colorspace < 4) {\n        var a = rgbToHsl(colorA);\n        var b = rgbToHsl(colorB);\n        var dist = Math.abs($bm_sub(a[0], b[0]));\n        result = interpolationMethod(t, tMin, tMax, a, b);\n        if (dist > 0.5 && colorspace == 2 || dist < 0.5 && colorspace == 3) {\n            var hA = a[0];\n            var hB = b[0];\n            var h = hA;\n            dist = $bm_sub(1, dist);\n            if (hA < hB) {\n                var limit = $bm_mul($bm_div(hA, dist), tMax);\n                if (t < limit)\n                    h = interpolationMethod(t, tMin, limit, hA, 0);\n                else\n                    h = interpolationMethod(t, limit, tMax, 1, hB);\n            } else {\n                var limit = $bm_mul($bm_div($bm_sub(1, hA), dist), tMax);\n                if (t < limit)\n                    h = interpolationMethod(t, tMin, limit, hA, 1);\n                else\n                    h = interpolationMethod(t, limit, tMax, 0, hB);\n            }\n            result = [\n                h,\n                result[1],\n                result[2],\n                result[3]\n            ];\n        }\n        result = hslToRgb(result);\n    } else {\n        var rgbResult = interpolationMethod(t, tMin, tMax, colorA, colorB);\n        if (colorspace == 0)\n            result = rgbResult;\n        else {\n            var a = rgbToHsl(colorA);\n            var b = rgbToHsl(colorB);\n            var hslResult = interpolationMethod(t, tMin, tMax, a, b);\n            var h = rgbToHsl(rgbResult)[0];\n            result = [\n                h,\n                hslResult[1],\n                hslResult[2],\n                hslResult[3]\n            ];\n            result = hslToRgb(result);\n        }\n    }\n    return result;\n}\nfunction multSets(setA, setB) {\n    var r = [];\n    var countA = setA.length;\n    var countB = setB.length;\n    var count = countA;\n    if (countB < countA)\n        count = countB;\n    for (var i = 0; i < count; i++) {\n        r.push($bm_mul(setA[i], setB[i]));\n    }\n    return r;\n}\nfunction linearExtrapolation(t, tMin, tMax, value1, value2) {\n    if (tMax == tMin)\n        return $bm_div($bm_sum(value1, value2), 2);\n    return $bm_sum(value1, $bm_mul($bm_div($bm_sub(t, tMin), $bm_sub(tMax, tMin)), $bm_sub(value2, value1)));\n}\nfunction blink(A, B, frequency, offset, ratio, t) {\n    if (typeof frequency === 'undefined')\n        frequency = 1;\n    if (typeof offset === 'undefined')\n        offset = 0;\n    if (typeof ratio === 'undefined')\n        ratio = 0.5;\n    if (typeof t === 'undefined')\n        t = time;\n    var phase = $bm_div(1, frequency);\n    var currentTime = $bm_mod($bm_sum(t, offset), phase);\n    var ADuration = $bm_mul(phase, ratio);\n    if (currentTime > ADuration)\n        return B;\n    return A;\n}\nfunction swing(A, B, frequency, offset, ratio, plateau, interpolationMethod, t) {\n    if (typeof frequency === 'undefined')\n        frequency = 1;\n    if (typeof offset === 'undefined')\n        offset = 0;\n    if (typeof ratio === 'undefined')\n        ratio = 0.5;\n    if (typeof plateau === 'undefined')\n        plateau = 0;\n    if (typeof interpolationMethod === 'undefined')\n        interpolationMethod = ease;\n    if (typeof t === 'undefined')\n        t = time;\n    var phase = $bm_div(1, frequency);\n    var currentTime = $bm_mod($bm_sum(t, offset), phase);\n    var ADuration = $bm_mul(phase, ratio);\n    var APlateau = $bm_mul(ADuration, plateau);\n    var BDuration = $bm_mul(phase, $bm_sub(1, ratio));\n    var BPlateau = $bm_mul(BDuration, plateau);\n    if (currentTime < $bm_sub(ADuration, APlateau))\n        return interpolationMethod(currentTime, 0, $bm_sub(ADuration, APlateau), A, B);\n    if (currentTime >= ADuration - APlateau && currentTime < ADuration)\n        return B;\n    if (currentTime >= ADuration && currentTime < phase - BPlateau)\n        return interpolationMethod(currentTime, ADuration, $bm_sub(phase, BPlateau), B, A);\n    return A;\n}\nif (frequencyValue > 0) {\n    offsetValue = $bm_div($bm_div(offsetValue, 100), frequencyValue);\n    ratioValue /= 100;\n    plateauValue /= 100;\n    var t = integrateLinearKeys(frequencyProp);\n    if (interpolationValue == 1)\n        result = $bm_sum(result, blink(AValue, BValue, 1, offsetValue, ratioValue, t));\n    else {\n        var i = linear;\n        if (interpolationValue == 3)\n            i = function (t, tMin, tMax, value1, value2) {\n                return bezierInterpolation(t, tMin, tMax, value1, value2, [\n                    $bm_div(rateValue, 10),\n                    0,\n                    $bm_sub(1, $bm_div(rateValue, 10)),\n                    1\n                ]);\n            };\n        if (interpolationValue == 4)\n            i = function (t, tMin, tMax, value1, value2) {\n                return gaussianInterpolation(t, tMin, tMax, value1, value2, linear(rateValue, 0, 10, -1, 1));\n            };\n        if (interpolationValue == 5)\n            i = function (t, tMin, tMax, value1, value2) {\n                return logInterpolation(t, tMin, tMax, value1, value2, $bm_mul($bm_mul(rateValue, 50), frequencyValue));\n            };\n        if (interpolationValue == 6)\n            i = function (t, tMin, tMax, value1, value2) {\n                return expInterpolation(t, tMin, tMax, value1, value2, $bm_mul(rateValue, frequencyValue));\n            };\n        var interpolator = i;\n        result = $bm_sum(result, swing(AValue, BValue, 1, offsetValue, ratioValue, plateauValue, interpolator, t));\n    }\n}\n$bm_rt = result;"}},"ao":0,"ef":[{"ty":5,"nm":"Scale | Swink","np":16,"mn":"Pseudo/DUIK 2D Swink","ix":1,"en":1,"ef":[{"ty":6,"nm":"Values","mn":"Pseudo/DUIK 2D Swink-0001","ix":1,"v":0},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0002","ix":2,"v":0},{"ty":3,"nm":"A","mn":"Pseudo/DUIK 2D Swink-0003","ix":3,"v":{"a":0,"k":[-175,-175],"ix":3}},{"ty":3,"nm":"B","mn":"Pseudo/DUIK 2D Swink-0004","ix":4,"v":{"a":0,"k":[25,25],"ix":4}},{"ty":6,"nm":"Parameters","mn":"Pseudo/DUIK 2D Swink-0005","ix":5,"v":0},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0006","ix":6,"v":0},{"ty":0,"nm":"Frequency","mn":"Pseudo/DUIK 2D Swink-0007","ix":7,"v":{"a":0,"k":0.15,"ix":7}},{"ty":0,"nm":"Cycle offset","mn":"Pseudo/DUIK 2D Swink-0008","ix":8,"v":{"a":0,"k":33.921,"ix":8}},{"ty":0,"nm":"A/B Ratio","mn":"Pseudo/DUIK 2D Swink-0009","ix":9,"v":{"a":0,"k":50,"ix":9}},{"ty":0,"nm":"Plateau","mn":"Pseudo/DUIK 2D Swink-0010","ix":10,"v":{"a":0,"k":0,"ix":10}},{"ty":6,"nm":"Interpolation","mn":"Pseudo/DUIK 2D Swink-0011","ix":11,"v":0},{"ty":7,"nm":"Mode","mn":"Pseudo/DUIK 2D Swink-0012","ix":12,"v":{"a":0,"k":3,"ix":12}},{"ty":0,"nm":"Rate","mn":"Pseudo/DUIK 2D Swink-0013","ix":13,"v":{"a":0,"k":3,"ix":13}},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0014","ix":14,"v":0}]}],"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[115.496,115.496],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.949019607843,0.949019607843,0.949019607843,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019607843,0.949019607843,0.949019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[13.946,15.584],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":167,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"Shape Layer 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10,"x":"var $bm_rt;\nfunction getOrientationAtTime(l, t) {\n    var r = 0;\n    r = $bm_sum(r, l.rotation.valueAtTime(t));\n    while (l.hasParent) {\n        l = l.parent;\n        r = $bm_sum(r, l.rotation.valueAtTime(t));\n    }\n    return r;\n}\nfunction checkDuikEffect(fx, duikMatchName) {\n    if (fx.numProperties < 3)\n        return false;\n    try {\n        if (fx(2)._name != duikMatchName)\n            return false;\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\nfunction getNextKey(t, prop) {\n    if (typeof t === 'undefined')\n        t = time;\n    if (typeof prop === 'undefined')\n        prop = thisProperty;\n    if (prop.numKeys == 0)\n        return null;\n    var nKey = prop.nearestKey(t);\n    if (nKey.time >= t)\n        return nKey;\n    if (nKey.index < prop.numKeys)\n        return prop.key($bm_sum(nKey.index, 1));\n    return null;\n}\nvar result = value;\nfor (var i = 1; i <= thisLayer('Effects').numProperties; i++) {\n    var fx = effect(i);\n    if (!fx.active)\n        continue;\n    if (!checkDuikEffect(fx, 'DUIK parentConstraint'))\n        continue;\n    if (!fx(8).value)\n        continue;\n    var l = null;\n    try {\n        l = fx(4);\n    } catch (e) {\n        continue;\n    }\n    if (!l)\n        continue;\n    if (l.index == index)\n        continue;\n    var cT = 0;\n    var mbPrecision = fx(10).value;\n    var step = $bm_div(framesToTime(1), mbPrecision);\n    while (cT < time) {\n        var nextT = $bm_sum(cT, step);\n        var roundedFrame = Math.round(timeToFrames(nextT));\n        var roundedTime = $bm_mul(roundedFrame, thisComp.frameDuration);\n        if ($bm_sub(nextT, roundedTime) < 0.0001)\n            nextT = roundedTime;\n        var wP = fx(5);\n        var nK = wP.numKeys;\n        if (nK < 2)\n            nextT = time;\n        else if (wP.key(1).time > time)\n            nextT = time;\n        else if (wP.key(1).time > nextT)\n            nextT = $bm_sum(wP.key(1).time, 0.001);\n        else if (wP.key(nK).time < nextT)\n            nextT = time;\n        else if (wP.velocityAtTime(nextT) == 0) {\n            var k = getNextKey(nextT, wP);\n            if (k && k.time > time)\n                nextT = time;\n            else if (k)\n                nextT = $bm_sum(k.time, 0.001);\n        }\n        var weight = $bm_div(wP.valueAtTime(cT), 100);\n        if (weight != 0) {\n            var P = getOrientationAtTime(l, nextT);\n            var oP = getOrientationAtTime(l, cT);\n            result = $bm_sum(result, $bm_mul($bm_sub(P, oP), weight));\n        }\n        cT = nextT;\n    }\n}\n$bm_rt = result;"},"p":{"a":0,"k":[250,250,0],"ix":2},"a":{"a":0,"k":[13.946,15.584,0],"ix":1},"s":{"a":0,"k":[74,74,100],"ix":6,"x":"var $bm_rt;\nvar fx = effect('Scale | Swink');\nvar AValue = fx(3).value;\nvar BValue = fx(4).value;\nvar frequencyProp = fx(7);\nvar interpolationValue = fx(12).value;\nvar rateValue = fx(13).value;\nvar offsetValue = fx(8).value;\nvar ratioValue = fx(9).value;\nvar plateauValue = fx(10).value;\nvar result = value;\nvar frequencyValue = frequencyProp.value;\nfunction bezierInterpolation(t, tMin, tMax, value1, value2, bezierPoints) {\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof bezierPoints === 'undefined')\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    if (arguments.length !== 5 && arguments.length !== 6)\n        return $bm_div($bm_sum(value1, value2), 2);\n    var a = $bm_sub(value2, value1);\n    var b = $bm_sub(tMax, tMin);\n    if (b == 0)\n        return $bm_div($bm_sum(value1, value2), 2);\n    var c = clamp($bm_div($bm_sub(t, tMin), b), 0, 1);\n    if (!(bezierPoints instanceof Array) || bezierPoints.length !== 4)\n        bezierPoints = [\n            0.33,\n            0,\n            0.66,\n            1\n        ];\n    return $bm_sum($bm_mul(a, h(c, bezierPoints)), value1);\n    function h(f, g) {\n        var x = $bm_mul(3, g[0]);\n        var j = $bm_sub($bm_mul(3, $bm_sub(g[2], g[0])), x);\n        var k = $bm_sub($bm_sub(1, x), j);\n        var l = $bm_mul(3, g[1]);\n        var m = $bm_sub($bm_mul(3, $bm_sub(g[3], g[1])), l);\n        var n = $bm_sub($bm_sub(1, l), m);\n        var d = f;\n        for (var i = 0; i < 5; i++) {\n            var z = $bm_sub($bm_mul(d, $bm_sum(x, $bm_mul(d, $bm_sum(j, $bm_mul(d, k))))), f);\n            if (Math.abs(z) < 0.001)\n                break;\n            d = $bm_sub(d, $bm_div(z, $bm_sum(x, $bm_mul(d, $bm_sum($bm_mul(2, j), $bm_mul($bm_mul(3, k), d))))));\n        }\n        return $bm_mul(d, $bm_sum(l, $bm_mul(d, $bm_sum(m, $bm_mul(d, n)))));\n    }\n}\nfunction gaussianInterpolation(t, tMin, tMax, value1, value2, rate) {\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 0;\n    if (value1 == value2)\n        return value1;\n    if (t >= tMax)\n        return value2;\n    if (t <= tMin)\n        return value1;\n    if (t != tMin) {\n        var newValue1 = gaussianInterpolation(tMin, tMin, tMax, value1, value2, rate);\n        var offset = $bm_sub(newValue1, value1);\n        value1 = $bm_sub(value1, offset);\n    }\n    if (rate < 0)\n        rate = $bm_mul(rate, 10);\n    rate = linear(t, tMin, tMax, 0.25, rate);\n    var r = $bm_sub(1, rate);\n    var fwhm = $bm_mul($bm_sub(tMax, tMin), r);\n    var center = tMax;\n    if (t >= tMax)\n        return value2;\n    if (fwhm === 0 && t == center)\n        return value2;\n    else if (fwhm === 0)\n        return value1;\n    var exp = $bm_mul(-4, Math.LN2);\n    exp *= Math.pow($bm_sub(t, center), 2);\n    exp *= $bm_div(1, Math.pow(fwhm, 2));\n    var result = Math.pow(Math.E, exp);\n    result = $bm_sum($bm_mul(result, $bm_sub(value2, value1)), value1);\n    return result;\n}\nfunction logInterpolation(t, tMin, tMax, vMin, vMax, rate) {\n    var value1, value2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 1;\n    if (rate == 0)\n        return linearExtrapolation(t, tMin, tMax, vMin, vMax);\n    tMax = $bm_sum($bm_mul($bm_sub(tMax, tMin), rate), 1);\n    t = $bm_sum($bm_mul($bm_sub(t, tMin), rate), 1);\n    if (t <= 1)\n        return vMin;\n    var m = Math.log(tMax);\n    var v = Math.log(t);\n    return linearExtrapolation(v, 0, m, vMin, vMax);\n}\nfunction expInterpolation(t, tMin, tMax, vMin, vMax, rate) {\n    var value1, value2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof value1 === 'undefined')\n        value1 = 0;\n    if (typeof value2 === 'undefined')\n        value2 = 0;\n    if (typeof rate === 'undefined')\n        rate = 1;\n    if (rate == 0)\n        return linearExtrapolation(t, tMin, tMax, vMin, vMax);\n    tMax = $bm_mul($bm_sub(tMax, tMin), rate);\n    t = $bm_mul($bm_sub(t, tMin), rate);\n    var m = Math.exp(tMax);\n    t = Math.exp(t);\n    return linearExtrapolation(t, 1, m, vMin, vMax);\n}\nfunction integrateLinearKeys(prop) {\n    if (typeof prop === 'undefined')\n        prop = thisProperty;\n    var nK = prop.numKeys;\n    if (nK < 2)\n        return $bm_mul(prop.value, $bm_sub(time, inPoint));\n    if (prop.key(1).time > time)\n        return $bm_mul(prop.value, $bm_sub(time, inPoint));\n    var result = $bm_mul(prop.key(1).value, $bm_sub(prop.key(1).time, inPoint));\n    for (var i = 2; i <= nK; i++) {\n        if (prop.key(i).time > time)\n            break;\n        var k1 = prop.key($bm_sub(i, 1));\n        var k2 = prop.key(i);\n        result = $bm_sum(result, $bm_div($bm_mul($bm_sum(k1.value, k2.value), $bm_sub(k2.time, k1.time)), 2));\n    }\n    result = $bm_sum(result, $bm_div($bm_mul($bm_sum(prop.value, prop.key($bm_sub(i, 1)).value), $bm_sub(time, prop.key($bm_sub(i, 1)).time)), 2));\n    return result;\n}\nfunction interpolateColor(t, colorspace, tMin, tMax, colorA, colorB, interpolationMethod) {\n    if (typeof t === 'undefined')\n        t = time;\n    if (typeof colorspace === 'undefined')\n        colorspace = 2;\n    if (typeof tMin === 'undefined')\n        tMin = 0;\n    if (typeof tMax === 'undefined')\n        tMax = 1;\n    if (typeof colorA === 'undefined')\n        colorA = [\n            0,\n            0,\n            0,\n            0\n        ];\n    if (typeof colorB === 'undefined')\n        colorB = [\n            1,\n            1,\n            1,\n            1\n        ];\n    if (typeof interpolationMethod === 'undefined')\n        interpolationMethod = ease;\n    var result = [\n            0,\n            0,\n            0,\n            0\n        ];\n    if (colorspace > 0 && colorspace < 4) {\n        var a = rgbToHsl(colorA);\n        var b = rgbToHsl(colorB);\n        var dist = Math.abs($bm_sub(a[0], b[0]));\n        result = interpolationMethod(t, tMin, tMax, a, b);\n        if (dist > 0.5 && colorspace == 2 || dist < 0.5 && colorspace == 3) {\n            var hA = a[0];\n            var hB = b[0];\n            var h = hA;\n            dist = $bm_sub(1, dist);\n            if (hA < hB) {\n                var limit = $bm_mul($bm_div(hA, dist), tMax);\n                if (t < limit)\n                    h = interpolationMethod(t, tMin, limit, hA, 0);\n                else\n                    h = interpolationMethod(t, limit, tMax, 1, hB);\n            } else {\n                var limit = $bm_mul($bm_div($bm_sub(1, hA), dist), tMax);\n                if (t < limit)\n                    h = interpolationMethod(t, tMin, limit, hA, 1);\n                else\n                    h = interpolationMethod(t, limit, tMax, 0, hB);\n            }\n            result = [\n                h,\n                result[1],\n                result[2],\n                result[3]\n            ];\n        }\n        result = hslToRgb(result);\n    } else {\n        var rgbResult = interpolationMethod(t, tMin, tMax, colorA, colorB);\n        if (colorspace == 0)\n            result = rgbResult;\n        else {\n            var a = rgbToHsl(colorA);\n            var b = rgbToHsl(colorB);\n            var hslResult = interpolationMethod(t, tMin, tMax, a, b);\n            var h = rgbToHsl(rgbResult)[0];\n            result = [\n                h,\n                hslResult[1],\n                hslResult[2],\n                hslResult[3]\n            ];\n            result = hslToRgb(result);\n        }\n    }\n    return result;\n}\nfunction multSets(setA, setB) {\n    var r = [];\n    var countA = setA.length;\n    var countB = setB.length;\n    var count = countA;\n    if (countB < countA)\n        count = countB;\n    for (var i = 0; i < count; i++) {\n        r.push($bm_mul(setA[i], setB[i]));\n    }\n    return r;\n}\nfunction linearExtrapolation(t, tMin, tMax, value1, value2) {\n    if (tMax == tMin)\n        return $bm_div($bm_sum(value1, value2), 2);\n    return $bm_sum(value1, $bm_mul($bm_div($bm_sub(t, tMin), $bm_sub(tMax, tMin)), $bm_sub(value2, value1)));\n}\nfunction blink(A, B, frequency, offset, ratio, t) {\n    if (typeof frequency === 'undefined')\n        frequency = 1;\n    if (typeof offset === 'undefined')\n        offset = 0;\n    if (typeof ratio === 'undefined')\n        ratio = 0.5;\n    if (typeof t === 'undefined')\n        t = time;\n    var phase = $bm_div(1, frequency);\n    var currentTime = $bm_mod($bm_sum(t, offset), phase);\n    var ADuration = $bm_mul(phase, ratio);\n    if (currentTime > ADuration)\n        return B;\n    return A;\n}\nfunction swing(A, B, frequency, offset, ratio, plateau, interpolationMethod, t) {\n    if (typeof frequency === 'undefined')\n        frequency = 1;\n    if (typeof offset === 'undefined')\n        offset = 0;\n    if (typeof ratio === 'undefined')\n        ratio = 0.5;\n    if (typeof plateau === 'undefined')\n        plateau = 0;\n    if (typeof interpolationMethod === 'undefined')\n        interpolationMethod = ease;\n    if (typeof t === 'undefined')\n        t = time;\n    var phase = $bm_div(1, frequency);\n    var currentTime = $bm_mod($bm_sum(t, offset), phase);\n    var ADuration = $bm_mul(phase, ratio);\n    var APlateau = $bm_mul(ADuration, plateau);\n    var BDuration = $bm_mul(phase, $bm_sub(1, ratio));\n    var BPlateau = $bm_mul(BDuration, plateau);\n    if (currentTime < $bm_sub(ADuration, APlateau))\n        return interpolationMethod(currentTime, 0, $bm_sub(ADuration, APlateau), A, B);\n    if (currentTime >= ADuration - APlateau && currentTime < ADuration)\n        return B;\n    if (currentTime >= ADuration && currentTime < phase - BPlateau)\n        return interpolationMethod(currentTime, ADuration, $bm_sub(phase, BPlateau), B, A);\n    return A;\n}\nif (frequencyValue > 0) {\n    offsetValue = $bm_div($bm_div(offsetValue, 100), frequencyValue);\n    ratioValue /= 100;\n    plateauValue /= 100;\n    var t = integrateLinearKeys(frequencyProp);\n    if (interpolationValue == 1)\n        result = $bm_sum(result, blink(AValue, BValue, 1, offsetValue, ratioValue, t));\n    else {\n        var i = linear;\n        if (interpolationValue == 3)\n            i = function (t, tMin, tMax, value1, value2) {\n                return bezierInterpolation(t, tMin, tMax, value1, value2, [\n                    $bm_div(rateValue, 10),\n                    0,\n                    $bm_sub(1, $bm_div(rateValue, 10)),\n                    1\n                ]);\n            };\n        if (interpolationValue == 4)\n            i = function (t, tMin, tMax, value1, value2) {\n                return gaussianInterpolation(t, tMin, tMax, value1, value2, linear(rateValue, 0, 10, -1, 1));\n            };\n        if (interpolationValue == 5)\n            i = function (t, tMin, tMax, value1, value2) {\n                return logInterpolation(t, tMin, tMax, value1, value2, $bm_mul($bm_mul(rateValue, 50), frequencyValue));\n            };\n        if (interpolationValue == 6)\n            i = function (t, tMin, tMax, value1, value2) {\n                return expInterpolation(t, tMin, tMax, value1, value2, $bm_mul(rateValue, frequencyValue));\n            };\n        var interpolator = i;\n        result = $bm_sum(result, swing(AValue, BValue, 1, offsetValue, ratioValue, plateauValue, interpolator, t));\n    }\n}\n$bm_rt = result;"}},"ao":0,"ef":[{"ty":5,"nm":"Scale | Swink","np":16,"mn":"Pseudo/DUIK 2D Swink","ix":1,"en":1,"ef":[{"ty":6,"nm":"Values","mn":"Pseudo/DUIK 2D Swink-0001","ix":1,"v":0},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0002","ix":2,"v":0},{"ty":3,"nm":"A","mn":"Pseudo/DUIK 2D Swink-0003","ix":3,"v":{"a":0,"k":[-175,-175],"ix":3}},{"ty":3,"nm":"B","mn":"Pseudo/DUIK 2D Swink-0004","ix":4,"v":{"a":0,"k":[25,25],"ix":4}},{"ty":6,"nm":"Parameters","mn":"Pseudo/DUIK 2D Swink-0005","ix":5,"v":0},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0006","ix":6,"v":0},{"ty":0,"nm":"Frequency","mn":"Pseudo/DUIK 2D Swink-0007","ix":7,"v":{"a":0,"k":0.15,"ix":7}},{"ty":0,"nm":"Cycle offset","mn":"Pseudo/DUIK 2D Swink-0008","ix":8,"v":{"a":0,"k":77.533,"ix":8}},{"ty":0,"nm":"A/B Ratio","mn":"Pseudo/DUIK 2D Swink-0009","ix":9,"v":{"a":0,"k":50,"ix":9}},{"ty":0,"nm":"Plateau","mn":"Pseudo/DUIK 2D Swink-0010","ix":10,"v":{"a":0,"k":0,"ix":10}},{"ty":6,"nm":"Interpolation","mn":"Pseudo/DUIK 2D Swink-0011","ix":11,"v":0},{"ty":7,"nm":"Mode","mn":"Pseudo/DUIK 2D Swink-0012","ix":12,"v":{"a":0,"k":3,"ix":12}},{"ty":0,"nm":"Rate","mn":"Pseudo/DUIK 2D Swink-0013","ix":13,"v":{"a":0,"k":3,"ix":13}},{"ty":6,"nm":"","mn":"Pseudo/DUIK 2D Swink-0014","ix":14,"v":0}]}],"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[115.496,115.496],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"st","c":{"a":0,"k":[0.949019607843,0.949019607843,0.949019607843,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.949019607843,0.949019607843,0.949019607843,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[13.946,15.584],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":167,"st":0,"bm":0}],"markers":[]}